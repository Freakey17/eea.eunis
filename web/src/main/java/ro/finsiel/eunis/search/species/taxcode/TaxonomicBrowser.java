package ro.finsiel.eunis.search.species.taxcode;


import ro.finsiel.eunis.jrfTables.species.taxonomy.Chm62edtTaxcodeDomain;
import ro.finsiel.eunis.jrfTables.species.taxonomy.Chm62edtTaxcodePersist;

import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector;


/**
 * Class used in species-taxonomic-browser.
 * @author finsiel
 */
public class TaxonomicBrowser {
    private int nodeID;

    /**
     * Javascript tree.
     */
    public StringBuffer tree;

    /**
     * Whole tree.
     */
    public StringBuffer treeAll;

    /**
     * Maximum level.
     */
    public int maxlevel;

    /**
     * Level.
     */
    public String level1;
    List coduriL1;

    /**
     * Generate taxonomic tree.
     * @return Taxonomic species tree (displayable in Web page). String contains array of variables declared for JavaScript.
     */
    public StringBuffer getTree() {
        return tree;
    }

    /**
     * Creates a new instance of TaxonomicTree.
     */
    public TaxonomicBrowser() {
        // coduriL1 = new Chm62edtTaxcodeDomain().findWhereOrderBy("LEVEL = 'KINGDOM'", "ID_TAXONOMY");
        coduriL1 = new Chm62edtTaxcodeDomain().findWhereOrderBy("ID_TAXONOMY=ID_TAXONOMY_PARENT", "NAME");
    }

    /**
     * Iterator for list generated by SELECT * FROM chm62edt_taxonomy WHERE ID_TAXONOMY=ID_TAXONOMY_PARENT ORDER BY NAME.
     * @return List of Chm62edtTaxcodePersist objects.
     */
    public Iterator getIterator() {
        return coduriL1.iterator();
    }

    /** Generate 'arrayName' tree string beginning with first level.
     * @param arrayName name of tree string
     */
    public void getTree(String arrayName) {
        tree = new StringBuffer();
        nodeID = 0;
        level1 = getTree(arrayName, 1, 0, "");
    }

    /**
     * Generate 'arrayName' tree string beginning with level = 'level' and parent code = 'parentCode'.
     * @param arrayName name of tree string
     * @param level level
     * @param parentCode parent code
     */
    public void getTree(String arrayName, int level, String parentCode) {
        tree = new StringBuffer();
        nodeID = 0;
        level1 = getTree(arrayName, level, 0, parentCode);
    }

    /**
     * Generate 'arrayName' tree string beginning with level = 'level', parent node id = 'parentNodID'
     * and parent code = 'parentCode'.
     * @param arrayName name of tree string
     * @param level level
     * @param parentNodID parent node id
     * @param parentCode parent code
     * @return Tree (Javascript definition of the tree array).
     */
    public String getTree(String arrayName, int level, int parentNodID, String parentCode) {
        String r = null;
        StringBuffer localTree = new StringBuffer();
        StringBuffer childs = null;

        if (level <= maxlevel) {
            List lTaxcodes = null;

            if (level == 1) {
                lTaxcodes = new Chm62edtTaxcodeDomain().findWhereOrderBy("ID_TAXONOMY=ID_TAXONOMY_PARENT", "NAME");
            } else {
                lTaxcodes = getChildrenForThisParent(parentCode);
            }

            Iterator it = lTaxcodes.iterator();

            if (it.hasNext()) {
                childs = new StringBuffer();
            }
            while (it.hasNext()) {
                Chm62edtTaxcodePersist h = (Chm62edtTaxcodePersist) it.next();

                localTree.append(arrayName);
                localTree.append("[");
                localTree.append(nodeID++); // elementId
                localTree.append("]=\"");
                localTree.append(nodeID); // nodeId
                childs.append(nodeID);
                if (it.hasNext()) {
                    childs.append(",");
                }
                localTree.append("|");
                localTree.append(parentNodID);
                localTree.append("|");
                String sn = h.getTaxonomicName();

                while (sn.indexOf("\"") != -1) {
                    String aux = sn.substring(0, sn.indexOf("\"")) + "\\$";

                    sn = aux + sn.substring(sn.indexOf("\"") + 1);
                }
                localTree.append(h.getTaxonomicLevel() + " - " + sn.replace('$', '\"'));
                localTree.append("|");
                localTree.append("species-taxonomic-browser.jsp?idTaxExpanded=" + h.getIdTaxcode() + "&openNode=" + nodeID);
                localTree.append("|");
                String nextlevel = this.getTree(arrayName, level + 1, nodeID, h.getIdTaxcode());

                localTree.append(nextlevel != null);
                localTree.append("|");
                localTree.append(!it.hasNext());
                localTree.append("|");
                localTree.append(nextlevel);
                localTree.append("|");
                localTree.append(findLevel(h));
                localTree.append("\";\n");
            }
            tree.append(localTree);
        }
        if (childs != null) {
            r = childs.toString();
        }
        return r;
    }

    /**
     * Find taxonomy level.
     * @param tax taxonomy
     * @return taxonomy level
     */
    // private int findLevel(Chm62edtTaxcodePersist tax) {
    // List l1 = new Chm62edtTaxcodeAllJoinsDomain().findWhere("A.ID_TAXONOMY ='" + tax.getIdTaxcode() + "'");
    // if (l1 != null && l1.size() > 0) {
    // Chm62edtTaxcodeAllJoinsPersist t = (Chm62edtTaxcodeAllJoinsPersist) l1.get(0);
    // if (t.getId1() == null && t.getId2() == null && t.getId3() == null && t.getId4() == null && t.getId5() == null) return 1;
    // if (t.getId1() != null && t.getId2() == null && t.getId3() == null && t.getId4() == null && t.getId5() == null) return 2;
    // if (t.getId1() != null && t.getId2() != null && t.getId3() == null && t.getId4() == null && t.getId5() == null) return 3;
    // if (t.getId1() != null && t.getId2() != null && t.getId3() != null && t.getId4() == null && t.getId5() == null) return 4;
    // if (t.getId1() != null && t.getId2() != null && t.getId3() != null && t.getId4() != null && t.getId5() == null) return 5;
    // if (t.getId1() != null && t.getId2() != null && t.getId3() != null && t.getId4() != null && t.getId5() != null) return 6;
    // }
    // return 0;
    // }

    private int findLevel(Chm62edtTaxcodePersist tax) {
        List list = new Vector();
        int result = 0;

        try {
            list = new Chm62edtTaxcodeDomain().findWhere("ID_TAXONOMY = '" + tax.getIdTaxcode() + "'");
            if (list != null && list.size() > 0) {
                Chm62edtTaxcodePersist t = (Chm62edtTaxcodePersist) list.get(0);
                String str = t.getTaxonomyTree();
                StringTokenizer st = new StringTokenizer(str, ",");

                while (st.hasMoreTokens()) {
                    st.nextToken();
                    result++;
                }
                result++;
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            result = 0;
        }
        return result;
    }

    /**
     * List of children for parent node.
     * @param parent parent
     * @return list of children
     */
    private List getChildrenForThisParent(String parent) {
        List l2 = new Chm62edtTaxcodeDomain().findWhere("ID_TAXONOMY != ID_TAXONOMY_PARENT AND ID_TAXONOMY_PARENT ='" + parent + "'");

        if (l2 != null && l2.size() > 0) {
            return l2;
        } else {
            return new Vector();
        }
    }

}
